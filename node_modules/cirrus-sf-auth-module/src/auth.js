const chalk = require('chalk');
const redis = require('redis');
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const fetch = require('node-fetch');

const print = (string) => {
  if (process.env.DISABLE_AUTH_LOGS !== 'true') {
    console.log(`${chalk.bgWhite.bold('[AUTH]')} : ${string}`);
  }
};


if (process.env.AUTH_REQUIRED === 'false') {
  print(
    chalk.bgYellow('Authentication is off. To enable set AUTH_REQUIRED to true in .env')
  );
}

if (process.env.DISABLE_AUTH_LOGS === 'true') {
  console.log(`${chalk.bgWhite.bold('[AUTH]')} : Logs are disabled.`);
}

const requiredEnvVars = [
  'CF_CALLBACK_URL',
  'CF_CLIENT_ID',
  'CF_CLIENT_SECRET',
  'SESSION_SECRET',
  'AUTH_REQUIRED',
  'SF_AUTHORIZE_URL',
  'SF_TOKEN_URL',
];

const missingVars = [];

// check that all environment variables are present
requiredEnvVars.forEach((variable) => {
  if (!process.env[variable]) {
    missingVars.push(variable);
  }
});

// if there's missing environment variables, print them to the log
if (missingVars.length > 0) {
  print(
    chalk.bgRed(
      `The following environment variables are missing!\n -- ${missingVars.join('\n -- ')}`
    )
  );
  print(chalk.bgRed('Please note variables are CASE SENSITIVE.'));
  // disable auth if env vars are missing
  print(chalk.bgYellow('Auth has been disabled due to misconfiguration.'));
  process.env.AUTH_REQUIRED = 'false';
}

// middleware that will authenticate the router
const authMiddleware = (req, res, next) => {
  // if we're already authenticated
  if (process.env.AUTH_REQUIRED === 'false' || (req.session && req.session.isAuthed)) {
    // pass through to next request
    next();
  } else {
    // attempt to authenticate the user by using OAuth flow for Salesforce
    res.redirect(
      `${process.env.SF_AUTHORIZE_URL}` +
      `?response_type=code&client_id=${process.env.CF_CLIENT_ID}` +
      `&redirect_uri=${encodeURIComponent(process.env.CF_CALLBACK_URL)}`
    );
  }
};

// redis client for scalable session storage
const client = redis.createClient(process.env.REDIS_URL);

const sessionOpts = {
  saveUninitialized: false, // saved new sessions
  resave: false, // do not automatically write to the session store
  store: new RedisStore({
    client,
  }),
  secret: process.env.SESSION_SECRET,
  cookie: {
    httpOnly: true,
    maxAge: 1800000,
  },
};

const authenticate = (router) => {
  // session storage for remembering our authenticated user while the session is active
  // (until website is closed)
  router.use(session(sessionOpts));

  // this endpoint is called upon initiating access as a callback url from Salesforce
  // user isn't authenticated quite yet
  router.get('/auth/callback', (req, res) => {
    console.log('auth callback');
    // now we have a one time code (req.query.code)
    // we can use to attempt to authenticate the user against our connected app
    fetch(
      `${process.env.SF_TOKEN_URL}?code=${req.query.code}` +
      `&grant_type=authorization_code&client_id=${process.env.CF_CLIENT_ID}` +
      `&client_secret=${process.env.CF_CLIENT_SECRET}` +
      `&redirect_uri=${encodeURIComponent(process.env.CF_CALLBACK_URL)}`,
      { method: 'POST', body: 'a=1' })
      .then((resp) => {
        return resp.json();
      }).then((json) => {
        const sess = req.session;
        // parse the response, if we have an access token and refresh token, then auth is successful
        if (json.access_token) {
          // store our access & refresh token in session storage
          sess.accessToken = json.access_token;
          fetch(json.id, {
            method: 'GET',
            body: 'a=1',
            headers: {
              Authorization: `Bearer ${json.access_token}`,
            },
          })
          .then((resp) => {
            return resp.json();
          }).then((auth) => {
            if (auth.id) {
              sess.refreshToken = auth.refresh_token;
              // set isAuthed to true in session storage
              sess.isAuthed = true;
              // redirect user to the app
              res.redirect('/');
            }
          }).catch((err) => {
            console.log(err);
          });
        }
      }).catch((err) => {
        // catch any OAuth flow errors that may appear
        console.log(err);
      });
  });

  // use our auth middleware AFTER authentication flow routes
  // so unauthenticated users can access auth flow
  router.use(authMiddleware);
};

  // module constructor
module.exports = {
  authenticate,
};
