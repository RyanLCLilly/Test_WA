'use strict';

var fetch = require('node-fetch');
var jwt = require('jsonwebtoken');
var jwkToPem = require('jwk-to-pem');
var atob = require('atob');
var btoa = require('btoa');

var getJWKS = function getJWKS(idToken) {
  // fetch our JWKS config to convert to public key
  return fetch(process.env.OPENID_ISSUER + '/pf/JWKS', {
    method: 'GET',
    body: 'a=1'
  }).then(function (resp) {
    return resp.json();
  }).then(function (json) {
    // decode our token to extract the kid to match the signature key
    var decoded = JSON.parse(atob(idToken.split('.')[0]));

    var pem = void 0;
    // check the response from JWKS config url,
    // attempt to match the kid from the token to a signature
    json.keys.forEach(function (key) {
      // if this signature key's kid matches our decoded token's kid
      if (key.kid === decoded.kid) {
        // convert the JWKS signature key to a pem
        pem = jwkToPem(key);
      }
    });

    return pem;
  }).then(function (pem) {
    return Promise.resolve(pem);
  });
};

var verify = function verify(idToken, req) {
  return getJWKS(idToken).then(function (pem) {
    // verify the token signature with the signature we matched from JWKS
    return jwt.verify(idToken, pem, {
      algorithms: 'RS256',
      ignoreExpiration: true
    });
  }).then(function (result) {
    // if there's a result from verification...
    if (result &&
    // Check that all the JWT verified info matches our configurated info
    result.nonce === process.env.OPENID_NONCE && result.aud === process.env.OPENID_CLIENT_ID && result.iss === process.env.OPENID_ISSUER) {
      req.session.jwt = result;
      // if everything matches, authenticate the user
      return Promise.resolve(true);
    }
    return Promise.resolve(false);
  });
};

var getAuthCallbackURL = function getAuthCallbackURL(req) {
  return new Promise(function (resolve, reject) {
    var callbackURL = void 0;
    if (process.env.NODE_ENV === 'production') {
      callbackURL = req.get('X-Forwarded-Proto') + '://' + req.get('host') + process.env.OPENID_CALLBACK;
      resolve(callbackURL);
    } else if (process.env.NODE_ENV === 'development') {
      callbackURL = req.protocol + '://' + req.get('host') + process.env.OPENID_CALLBACK;
      resolve(callbackURL);
    } else {
      reject(callbackURL);
    }
  });
};

var redirectToAuth = function redirectToAuth(req, res) {
  getAuthCallbackURL(req).then(function (callback) {
    // attempt to authenticate the user by using OpenID flow
    res.redirect(process.env.OPENID_ISSUER + '/as/authorization.oauth2' + ('?scope=' + process.env.OPENID_SCOPE) + ('&client_id=' + process.env.OPENID_CLIENT_ID) + '&response_type=code' + ('&nonce=' + process.env.OPENID_NONCE) + ('&state=' + encodeURIComponent(req.originalUrl)) + ('&redirect_uri=' + encodeURIComponent(callback)));
  }).catch(function (e) {
    res.status(500, { error: e });
  });
};

var tokenRequest = function tokenRequest(req, callbackURL) {
  return fetch(process.env.OPENID_TOKEN_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      Authorization: 'Basic ' + btoa(process.env.OPENID_CLIENT_ID + ':' + process.env.OPENID_CLIENT_SECRET)
    },
    body: 'grant_type=authorization_code&code=' + req.query.code + ('&redirect_uri=' + encodeURIComponent(callbackURL))
  }).then(function (resp) {
    return resp.json();
  }).then(function (tokenResp) {
    return Promise.resolve(tokenResp);
  });
};

var tokenEndpoint = function tokenEndpoint(req) {
  return getAuthCallbackURL(req).then(function (callbackURL) {
    return tokenRequest(req, callbackURL);
  });
};

module.exports = {
  tokenEndpoint: tokenEndpoint,
  redirectToAuth: redirectToAuth,
  verify: verify,
  getAuthCallbackURL: getAuthCallbackURL
};