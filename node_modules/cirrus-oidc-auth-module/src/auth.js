const bodyParser = require('body-parser');
const chalk = require('chalk');
const authHelper = require('./auth-helper');
const session = require('./sessions');

const print = (string) => {
  if (process.env.DISABLE_AUTH_LOGS !== 'true') {
    console.log(`${chalk.bgWhite.bold('[AUTH]')} : ${string}`);
  }
};

if (process.env.AUTH_REQUIRED === 'false') {
  print(
    chalk.bgYellow('Authentication is off. To enable set AUTH_REQUIRED to true in .env')
  );
}

if (process.env.DISABLE_AUTH_LOGS === 'true') {
  console.log(`${chalk.bgWhite.bold('[AUTH]')} : Logs are disabled.`);
}

const requiredEnvVars = [
  'OPENID_CALLBACK',
  'OPENID_CLIENT_ID',
  'OPENID_CLIENT_SECRET',
  'OPENID_ISSUER',
  'OPENID_SCOPE',
  'OPENID_TOKEN_URL',
  'OPENID_USER_INFO_URL',
  'OPENID_NONCE',
  'COOKIE_SECRET',
];

const missingVars = [];

// check that all environment variables are present
requiredEnvVars.forEach((variable) => {
  if (!process.env[variable]) {
    missingVars.push(variable);
  }
});

// if there's missing environment variables, print them to the log
if (missingVars.length > 0) {
  print(
    chalk.bgRed(
      `The following environment variables are missing!\n -- ${missingVars.join('\n -- ')}`
    )
  );
  print(chalk.bgRed('Please note variables are CASE SENSITIVE.'));
  // disable auth if env vars are missing
  print(chalk.bgYellow('Auth has been disabled due to misconfiguration.'));
  process.env.AUTH_REQUIRED = 'false';
}

let retries = 0;

// middleware that will authenticate the router
const authMiddleware = (req, res, next) => {
    // Function for getting the enviroment of the user - Production or Development.
    // if we're already authenticated
  if (process.env.AUTH_REQUIRED === 'false') {
      // pass through to next request
    print(chalk.bgCyan(`Serving ${req.originalUrl} without authenticating user.`));
    next();
  } else if (req.session.isAuthed) {
    next();
  } else {
    print(chalk.bgRed('User is not authed, redirecting to authenticate...'));
    // cap amount of retries before closing the request
    if (retries > 4) {
      print(chalk.bgRed('Auth failed, too many redirects.'));
      retries = 0;
      res.end();
    } else {
      retries += 1;
      // redirect the user to auth
      authHelper.redirectToAuth(req, res);
    }
  }
};

const authenticate = (router) => {
  router.use(bodyParser.json());
  router.use(bodyParser.urlencoded({
    extended: true,
  }));
  // set the router/app up with redis session storage
  session(router);

  // this endpoint is called upon initiating access as a callback url from ping
  // user isn't authenticated quite yet
  router.get('/auth/callback', (req, res) => {
    // Send the request to the token endpoint which contains the access code
    authHelper.tokenEndpoint(req)
    .then((response) => {
      // store the access token, id token in session storage to access later
      req.session.access_token = response.access_token;
      req.session.id_token = response.id_token;
      return response.id_token;
    })
    .then((idToken) => {
      // verify the id token using JWKS algorithm
      return authHelper.verify(idToken, req);
    })
    .then((verified) => {
      // if we're verified, set an isAuthed flag on the session for subsequent requests
      req.session.isAuthed = verified;
      // redirect the user to their original url (stored in the state)
      res.redirect(req.query.state);
    })
    .catch((err) => {
      console.log(err);
      res.end();
    });
  });

  // use our auth middleware AFTER authentication flow routes
  // so unauthenticated users can access auth flow
  router.use(authMiddleware);
};

  // module constructor
module.exports = {
  authenticate,
};
