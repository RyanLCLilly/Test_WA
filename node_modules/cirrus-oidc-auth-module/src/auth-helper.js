const fetch = require('node-fetch');
const jwt = require('jsonwebtoken');
const jwkToPem = require('jwk-to-pem');
const atob = require('atob');
const btoa = require('btoa');

const getJWKS = (idToken) => {
  // fetch our JWKS config to convert to public key
  return fetch(`${process.env.OPENID_ISSUER}/pf/JWKS`, {
    method: 'GET',
    body: 'a=1',
  })
  .then((resp) => {
    return resp.json();
  }).then((json) => {
    // decode our token to extract the kid to match the signature key
    const decoded = JSON.parse(atob(idToken.split('.')[0]));

    let pem;
    // check the response from JWKS config url,
    // attempt to match the kid from the token to a signature
    json.keys.forEach((key) => {
      // if this signature key's kid matches our decoded token's kid
      if (key.kid === decoded.kid) {
        // convert the JWKS signature key to a pem
        pem = jwkToPem(key);
      }
    });

    return pem;
  })
  .then((pem) => {
    return Promise.resolve(pem);
  });
};


const verify = (idToken, req) => {
  return getJWKS(idToken)
  .then((pem) => {
    // verify the token signature with the signature we matched from JWKS
    return jwt.verify(idToken, pem, {
      algorithms: 'RS256',
      ignoreExpiration: true,
    });
  })
  .then((result) => {
    // if there's a result from verification...
    if (
      result &&
      // Check that all the JWT verified info matches our configurated info
      (result.nonce === process.env.OPENID_NONCE) &&
      (result.aud === process.env.OPENID_CLIENT_ID) &&
      (result.iss === process.env.OPENID_ISSUER)
    ) {
      req.session.jwt = result;
      // if everything matches, authenticate the user
      return Promise.resolve(true);
    }
    return Promise.resolve(false);
  });
};

const getAuthCallbackURL = (req) => {
  return new Promise((resolve, reject) => {
    let callbackURL;
    if (process.env.NODE_ENV === 'production') {
      callbackURL = `${req.get('X-Forwarded-Proto')}://${req.get('host')}${process.env.OPENID_CALLBACK}`;
      resolve(callbackURL);
    } else if (process.env.NODE_ENV === 'development') {
      callbackURL = `${req.protocol}://${req.get('host')}${process.env.OPENID_CALLBACK}`;
      resolve(callbackURL);
    } else {
      reject(callbackURL);
    }
  });
};

const redirectToAuth = (req, res) => {
  getAuthCallbackURL(req)
  .then((callback) => {
    // attempt to authenticate the user by using OpenID flow
    res.redirect(
      `${process.env.OPENID_ISSUER}/as/authorization.oauth2` +
      `?scope=${process.env.OPENID_SCOPE}` +
      `&client_id=${process.env.OPENID_CLIENT_ID}` +
      '&response_type=code' +
      `&nonce=${process.env.OPENID_NONCE}` +
      `&state=${encodeURIComponent(req.originalUrl)}` +
      `&redirect_uri=${encodeURIComponent(callback)}`
    );
  })
  .catch((e) => {
    res.status(500, { error: e });
  });
};


const tokenRequest = (req, callbackURL) => {
  return fetch(process.env.OPENID_TOKEN_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      Authorization:
      `Basic ${btoa(`${process.env.OPENID_CLIENT_ID}:${process.env.OPENID_CLIENT_SECRET}`)}`,
    },
    body:
    `grant_type=authorization_code&code=${req.query.code}` +
    `&redirect_uri=${encodeURIComponent(callbackURL)}`,
  })
  .then((resp) => {
    return resp.json();
  })
  .then((tokenResp) => {
    return Promise.resolve(tokenResp);
  });
};

const tokenEndpoint = (req) => {
  return getAuthCallbackURL(req)
  .then((callbackURL) => {
    return tokenRequest(req, callbackURL);
  });
};

module.exports = {
  tokenEndpoint,
  redirectToAuth,
  verify,
  getAuthCallbackURL,
};
